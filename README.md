#Kalyani's Mars Rover Excercise
## Introduction
This project is for mars rover tech excercise using typescript
## Goal
Completing mars rover technical assessment
## Creating your application

This app is a a template for mars rover tech assessment

ðŸ‘‰ First, fork and clone this repository.

ðŸ‘‰ Then run this command:

```
npm install
```

ðŸ‘‰ You can then run

```
npm test
```

ðŸ‘‰ You can then run

```
npm start
```
## Testing your application
Example Test Case 
Lines of Input to the Program: 5 5 
1 2 N 
LMLMLMLMM 
3 3 E 
MMRMMRMRRM 
Expected Output: 
1 3 N 
5 1 E

## Technical Details for starting from scratch
ðŸ‘‰ Create a new project using code editor ex: VS Code
ðŸ‘‰ Add the required dependencies for typescript, npm install typescript --save-dev
ðŸ‘‰ Add a tsconfig.json file to the root of the project
ðŸ‘‰ Created folder structure to differenciate components
ðŸ‘‰ In my cases added folders src, tests to the root folder
ðŸ‘‰ Install testing framework, I have used jest 
npm install jest ts-jest @types/jest --save-dev
ðŸ‘‰ configure jest using jest.config.js file
ðŸ‘‰ To compile type script project need to use npx tsc 

## Future extension of code according to my mars-rover-project
ðŸ‘‰User Interface Enhancements: Improve the user interface by adding a graphical representation of the plateau and rover movements.
ðŸ‘‰Command Line Arguments: Extend the program to accept command line arguments for providing the plateau size, rover positions, and instructions. This would make it easier for users to run the program and simulate multiple rover scenarios without requiring manual input.
ðŸ‘‰Logging and Debugging: Add logging functionality to record important events, errors, and rover movements during runtime. This would assist in debugging and troubleshooting the program and provide valuable insights for analysis and improvement.
ðŸ‘‰Performance Optimization: Analyze the code for performance bottlenecks and optimize critical sections to improve the execution speed and efficiency of the program. This could involve using algorithms with better time complexity or implementing caching mechanisms where applicable.
ðŸ‘‰Code Refactoring and Modularity: Continuously refactor the codebase to improve readability, maintainability, and adherence to best practices. Break down complex functions into smaller, more modular components and ensure proper separation of concerns to make the codebase more scalable and easier to maintain.



